import math

from manim import *
import itertools as it
import random as rd
import numpy as np

config.frame_width = 16
config.frame_height = 9
from hashlib import sha256
import binascii

from colour import Color




q = 0.3
qq = 2 * q
qqq = 3 * q

L = LEFT
R = RIGHT
U = UP
D = DOWN


class LabeledRectangle(RoundedRectangle):

    def __init__(
            self,
            label: str or SingleStringMathTex or Text or Tex,
            width: float or None = None,
            height: float or None = None,
            corner_radius: float or None = None,
            direction: np.ndarray = UP,
            **kwargs, ) -> None:

        if isinstance(label, str):
            from manim import Tex

            rendered_label = Tex(label, color=WHITE)
        else:
            rendered_label = label

        if width is None:
            width = 0.2 + max(rendered_label.width, rendered_label.height)
        if height is None:
            height = 0.2 + max(rendered_label.height, rendered_label.height)

        if corner_radius is None:
            corner_radius = 0.2

        super().__init__(width=width, height=height, corner_radius=corner_radius, **kwargs)
        rendered_label.next_to(self, direction)
        self.add(rendered_label)

def create_asset_mob(text, width=0.5, height=0.3, fill_color=GREEN, stroke_color=GREEN):
    box = Rectangle(width=width, height=height, fill_color=fill_color, stroke_color=stroke_color, fill_opacity=1)
    text = Text(text, color=BLACK).scale(height)

    return VGroup(box, text)

def create_entity(person_name, person_radius, person_color, asset_name, asset_color, asset_width, asset_height):
    person = LabeledDot(person_name, radius=person_radius, fill_opacity=1.0, color=person_color)

    box = Rectangle(width=asset_width, height=asset_height, fill_color=asset_color, stroke_color=asset_color, fill_opacity=1)
    text = Text(asset_name, color=BLACK).scale(asset_height)

    asset = VGroup(box, text).next_to(person, DOWN, buff=0.1)

    return VGroup(person, asset)

class final(Scene):
    def construct(self):
        pass

        # lec1_s1.construct(self)
        # lec1_s2.construct(self)
        # lec1_s3.construct(self)
        # lec1_s4.construct(self)
        # working.construct(self)



class working1(Scene):
    def construct(self):
        swap_text = Tex('Swap').scale(2)
        # 그렇다면 덱스가 존재하는 이유는 무엇일까요
        tex_1 = Tex('Why dex?').scale(2)

        #####     그렇다면 덱스가 존재하는 이유는 무엇일까요
        # 중앙화 노드 왼쪽 탈중앙화 노드 오른쪽



        #####     일단 중앙화 주체 없이 운영되는 거래소이기 때문에 오는 장점이 잇습니다
        # 중앙화 노드로 공격 애니메이션
        # 중앙 노드가 없어지면서 라인도 네트워크 라인도 같이 제거


        #####  덱스는 중앙화 서버가 없고 블록체인에 의존하기 때문에 서버가 죽는 위험에 노출되지 않습니다
        # 탈중앙화는 살아있음

        ##### 그러나 블록체인 네트워크도 트래픽이 많으면 느려지고 심지어 최근 솔라나나 클레이튼 대형체인도
        # 블록생성하다가 속도 존나 줄이기
        # 블록생성하다가 멈추고 뒤에 빨ㄹ간스톱사인


        ##### 정지하는 일도 심심치 않게 발생합니다. 그래서 무작정 중앙서버보다 좋다고만은 할 수도 없습니다


        ##### 또 정부의 검열으로부터 자유로울 수 있고 프라이버시를 보호할 수 있습니다
        # 덱스중앙에 텍스트
        # 눈 아이콘생성
        # 방어막

        ##### 모든 기록이 블록체인에 남지만 그 주소가 누군지 매칭이 안 되기 때문에 익명성이 보장됩니다
        # 블록하나 왼쪽상단 옆에는 프럼 주소 아래 화살표와 내용 그리고 투 주소
        # 그리고 물음표 아이콘

        ##### 그리고 거래소의 심사 없이 코인을 자유롭게 상장할 수 있ㅅ브니다
        ##### 크립토 프로젝트들은 거래소에서 심사를 거쳐 상장이 되야하는데 이 기준이 엄격하다보닏
        ##### 거래소에는 한정된 코인들만 있ㅅ브니다.
        ##### 그러나 덱스에서는 누구나 유동성 풀을 만들어 다른 사람들의 거래를 도울 수 있습니다

        # 중앙화 거래소 오른쪽에 생성 그리고 중앙에 Eval and audit 으로 필터 막대 설정
        # 잡코인들 존나 부닥치고 튕겨나감
        # 덱스똑같이 생성시키고 유동성제공자 만든 다음에 지폐 두장 보내면 덱스에서 페어 아이콘으로 형성
        # 할 때 코인 이름 구린걸로

        ##### 그러면 도대체 누구 좋으라고 유동성을 공급해줄까요?
        # 포 왓 띄워줌
        # 자선사업가임

        ##### 덱스가 존재하는 이유 중 하나는 수익원 제공입니다
        # 돈아이콘 띄움

        ##### 덱스로 수익을 낼수 있는 루트 중 하나는 유동성 풀 제공입니다
        # 유동성 풀에서 돈이 나오는 애니메이션


        ##### 아까 말했듯이 비트코인과 테더를 묶어 유동성 풀에 넣게 되면 공급자의 지갑에서 비트와 테더는 없어지고 엘피토큰이 남습니다.
        ##### 이 엘피 토큰은 전체 풀 사이즈에서 내가 차지하는 비중이 얼마인지를 나타냅니다
        # 유동성 제공자가 유동성 제공하고
        스왑이 일어나는데 스왑하려고 보낼 때



        ##### 최초로 누군가 비트테더 풀을 만들고 엘피토큰을 10개 받았습니다
        ##### 그리고 거래가 발생할 때마다 보통 0.3퍼센트의 수수료를 내는데 이 수수료는 lP풀에 쌓이게 됩니다
        ##### 그 뒤로 누군가 유동성을 추가하면 그 전체 유동성 풀의 가치에
        ##### 그리고 엘피토큰을 부수고 다시 엘피를 이루는 비트와 테더로 받을 때
        ##### 전체 유동성 풀에서 차지하는 비중 만큼 코인을 빼오지만 풀 자체가 수수료로 점점 커졌기 때문에
        ##### 수익이 발생합니다.
        #####
        ##### 유동성 풀 말고도 덱스는 다양한 금융상품등을 제공합니다
        ##### 이에 대해서는 나중에 더 자세하게 알아봅니다


class working2(Scene):
    def construct(self):
        circle = Circle(radius=20, fill_color=ORANGE, fill_opacity=1)
        # self.add(circle)
        self.play(Create(circle))
        self.wait(15)



##### 그리하여 오늘은 에이엠엠ㅇ과 엑스와잉는 케이 공식에 대해 알아보겠습니다
#####
##### 원래 덱스는 이더리움 생태계에서 나왔고 비트코인이 wbtc같이 이더리움 체인에서
##### 사용된 건 시간이 걸렸지만 이해를 위해 그냥 비티씨를 사용하겠스빈다
##### 최초의 뎩스가 탄생하고 사람들은 비트코인과 usdt의 거래쌍을 만들고 싶었습니다.
##### 그래서 중앙화 거래소에서 비트코인 가격이 300달러인 걸 보고
##### 비트코인 10개와 3000달러를 함께 유동성 풀이라는 것에 넣었습니다
##### 이것은 일종의 스마트 컨트랙트로 자신의 자산으로 유동성을 제공하곘다는 것입니다.
##### 이제 이 유동성 제공자로 인하여 덱스참여자는 비트코인과 테더 거래쌍을 이용할 수 있습니다
#####
#####
#####
#####
##### 말만 들으면 뭔지 이해가 안 될테니 이제 자세히 알아보겠습니다
#####
##### 일단 우리가 알고있는 오더북이 없이 어떻게 거래를 하는가가 궁금하실 겁니다
##### 오더북에서는 그저 사람들이 거래하는 것을 바탕으로 알아서 각겨이 정해집니다
##### 덱스에서는 오더북대신 오토매틱마켓메이커를 사용하고
##### 그냥 프로그램 혹은 가격을 정하는 방식같은 추상적 개념이라고 생각하시면 됩니다
##### 오토매틱마켓메이커는 줄여서 amm이라고 부르고
##### 오토매틱마켓메이커를 돌리는데는 일반적으로 유동성 풀이 필요합니다
##### 이 유동성 풀은 우리가 중앙화 거래소에서 봤던 거래쌍이라고 생각하시면 됩니ㅏㄷ
##### 우리가 비티씨나 테더를 들고 중앙화 거래소에서 비티씨테더 거래쌍 창으로 가듯이
##### 덱스에서는 유동성 풀에 접근해서 거래를 하게됩니다
##### 그렇다면 비티씨테더 풀이라는 것은 이더리움 같은게 아니라 비티씨와 테더를 가지고 있어야할 것입니다
##### 중앙화 거래소 비티씨테더 페어에서 사람들이 이더리움을 들고 모인게 아니라
##### 비티씨와 테더를 들고 모인것 처럼 말입니다
##### 당연한 얘기지만 비티씨 테더 페어에 만약 비티씨만 존재한다면 아무것도 일어나지 않을 것입니다
##### 왜냐하면 비티씨 테더 페어라는 것은 두가지의 교환이 일어나는 공간이라는 것인데
##### 둘 중 하나만 있으면 교환이 성립하지 않으니까요
#####
##### 그래서 우리는 풀에 사람들이 거래할 수 있도록 유동성을 공급하고
##### 유동성을 공급한다는 것은 비티씨와 테더를 같이 넣어준다는 것입니다
##### 반드시 같이 넣어야하는 이유는 곧 알게됩니다
#####
##### 풀이 운영되는 기본 원칙은 언제나 같은 가치의 자산이 들어있게 한다는 것입니다
##### 그래서 이걸 기반으로 오토매틱 마켔메이커는 가격을 산정합니다
##### 현재 초기 공급자만 비티씨와 테더를 넣었고
##### 10비티씨와 3000테더라고 하겠습니다
##### 10비트와 3000테더가 같은 가치기 때문에
##### 비티씨는 1개에 300테더입니다
##### 이제 사람들은 풀에 자신이 테더를 넣고 그에 상응하는 비트코인을 빼가든지
##### 가진 비트코인을 넣고 그에 상응하는 테더를 빼가든지 할 수 있습니다
##### 각각 비트코인 매도와 매수에 대응하는 행위입니다
#####
##### 덱스의 있는 참여자는 크게 두 종류입니다
##### 유동성 제공자와 거래자입니다
##### 유동성 제공자는 아까처럼 말한 것처럼 비티씨와 테더를 같이 넣어주거나 빼면서
##### 유동성을 조절합니다. 즉 풀 사이즈를 키우거나 줄입니다. 이것은 나중에 보겠지만
##### 케이값을 움직이는 것입니다. 곧 보게 될테니 걱정 안 하셔도 됩니다
##### 그리고 거래자는 그 풀에서 자신이 원하는대로 코인을 사고 팔며 거래합니다
##### 이것은 그래프위의 점을 이동시키는 행위입니다.
##### 이것또한 곳 보게 될테니 걱정 안 하셔도 됩니다
##### 유동성제공자는 케이값을 움직이고 거래자는 점을 이동시킨다라고만 기억해두십시오
#####
##### 그리고 유동성 제공자는 거래자들이 내는 수수료를 받으면서 수익을 냅니다
##### 거래자들은 코인을 사고 팔며 가격차익을 얻습니다
#####
##### 이것은 모두 미리 작성된 프로그래밍 언어의 스크립트를 실행하는 것으로 이루어집니다
##### 스마트 컨트랙트 덕분에 우리는 중앙화 거래서와 같은 제3자를 거치지 않을 수 있게 됐습니다
#####
#####
#####
##### 간단하게 오토매틱 마켓 메이커를 통해 덱스가 돌아가는 원리를 배웟는데
##### 이젠 약간의 수학과 함께 더욱 자세히 알아보겠습니다
#####
#####
##### 조금 더 자셰히 알아봅시다
#####
##### 엑스와이는 케이에서 엑스를 이항시키면
##### 와이는 엑스부느이 케이 형태입니다
##### 여러분 모두 중학교 때 함수를 배웠을 것이고
##### 기본적인  와이는 2엑스도 배웠고 와이는 엑스분의 1을 빼운기억이 날겁니다
##### 그중에 엑스분의 1함수는 반비례함수라고 배웠고 쌍곡선의 형태를 띄는 함수입니다
##### 그리고 이 반비레함수는 케이값에 따라서
##### 보이는 것과 같이 원점에서 점점 멀어지는 함수입니다
##### 일반적인 오토매틱 마켓메이커는 이 함수를 사용해 가격을 결정합니다
##### 도대체 어떻게 가격을 결정하는지 알아보겠습니다
#####
##### 여기서 엑스는 a코인의 양 와이는 비코인의 양입니다
##### 페어라는 것이 원래 양방향이어서 서로 바꿔도 무방하나
##### 앞으로 이해하기 쉽게 풀내부의 베이스에셋의 양이 풀내부의 엑스 쿼트에셋의 양이 와이라고
##### 우리가 살펴볼 비티씨테더 페어에서는
##### 엑스는 풀내부 비티씨의 양
##### 왕이는 풀내부 테더의 양입니다
#####
##### 복잡하게 생각할 건 없고 와이는 엑스분의케이 그래프에서 케이는 그냥 어떤 값입니다.
##### 그런데 아까 우리는 케이가 엑스 곱하기 와이인 걸 봤습니다.
#####
##### 자 그렇다면 현재 비티씨테더 풀의 공식은
##### 와이는 엑스분의 30000입니다
#####
##### 아까 말한 것처럼 가격은 풀에 각 코인이 얼마나 있는지로 결정되기 때문에
##### 풀의 상태로 우리는 가격을 계산할 수 있습니다
##### 엑스와이는 케이가 풀을 나타내는 방정식이고
##### 풀의 상태는 아까 본 와이는 엑스분의 케이라는 함수의 그래프 위의
##### 한 점으로 나타낼 수 있습니다. 여기에는 가격정보도 들어있는 것입니다.
#####
##### 그리고 누군가 풀을 대상으로 비티씨를 매수하거나 매도한다는 것은
##### 풀의 상태를 변화 시키는 것이기에 현재 있는 지점에서 그래프 상의 다른 지점으로 이동한다는 것입니다
#####
##### 그리고 유동성을 공급하거나 제거한다는 것은 케이값을 움직이는 것입니다.
##### 엑스와 와이가 둘다 줄면 당연히 케이값도 줄것이고
##### 유동성을 공급하는 것은 엑스와 와이가 둘다 늘면
#####
#####
##### 이걸 원점으로 생각하고 상황에따라 어떻게 변하는지 보겠습니다.
#####
##### .
#####
#####
#####
#####
#####
##### 우린 엑스와이케이를 컨스턴트 프로덕트 즉 곱의 값이 일정한 모델이라 부릅니다
##### 곱의 값이 일정하려면 하나가 늘면 하나가 줄어야합니다.
##### 풀에 비티씨가 들어오면 즉 비티씨를 매도하는 사람이 있으면 테더가 빠져나가는 것입니다
##### 비티씨를 매도한다는 것은 풀에 비티씨를 넣고 테더를 빼간다는 것이고
##### 이 때 변화가 일어난 후에도 엑스와이는 케이에 따르면 케이값은 일정해야 한다는 것이 주요 아이디어입니다
#####
#####
#####
##### 순서를 곰곰히 따져봅시다
##### 현재 이벤트가 발생하는 순서는
##### 1 거래자가 자신이 비티씨를 매도하고 싶어서 풀에 5비티씨를 넣었다
##### 2 풀에서는 스마트 컨트랙트대로 그에 상응하는 테더를 꺼내준다
##### 변화의 시작이 어디였을까요?바로 비티씨의 추가입니다
##### 그러면 1번 이벤트까지만 진행됐을 때 우리는 엑스값을 변화시켜줍니다
##### 케이값은 30000이었고 엑스와이는 케이에서 이제 새로운 엑스값
##### 3개가 추가됐으니 15을 알고 케이값을 압니다 그러면 나머지 y를 계산할 수 있게 됩니다.
##### 이 와이값은 케이가 30000이고 x, 즉 풀내부의 비티씨가 15개일 때 존재햬야만 하는 테더의 양입니다
##### 계산해보면 2000테더이고 2000테더가 존재해야만 하니까 매도자는 현재 3000테더에서 2000을 뺀
##### 1000테더를 가져갈 수 있는 것입니다
##### 이제 2번 이벤트에 필요한 정보를 알고있으니 2번 이벤트가 발생하고 거래가 완료됩니다
#####
#####
##### 순서를 곰곰히 따져봅시다
##### 현재 이벤트가 발생하는 순서는
##### 1 거래자가 자신이 비티씨를 매도하고 싶어서 풀에 5비티씨를 넣었다
##### 2 풀에서는 스마트 컨트랙트대로 그에 상응하는 테더를 꺼내준다
##### 변화의 시작이 어디였을까요?바로 비티씨의 추가입니다
##### 그러면 1번 이벤트까지만 진행됐을 때 우리는 엑스값을 변화시켜줍니다
##### 케이값은 30000이었고 엑스와이는 케이에서 이제 새로운 엑스값
##### 3개가 추가됐으니 15을 알고 케이값을 압니다 그러면 나머지 y를 계산할 수 있게 됩니다.
##### 이 와이값은 케이가 30000이고 x, 즉 풀내부의 비티씨가 15개일 때 존재햬야만 하는 테더의 양입니다
##### 계산해보면 2000테더이고 2000테더가 존재해야만 하니까 매도자는 현재 3000테더에서 2000을 뺀
##### 1000테더를 가져갈 수 있는 것입니다
##### 이제 2번 이벤트에 필요한 정보를 알고있으니 2번 이벤트가 발생하고 거래가 완료됩니다


